function barchart(data, startDate, endDate) {

    let symptoms = data.filter(row => {
        let date = new Date(row.initial_time);
        return date >= startDate && date <= endDate;
    }).map(d => d.symptoms);

    let symptoms_map = symptoms.reduce((acc, val) => acc.set(val, 1 + (acc.get(val) || 0)), new Map());
    let symptom_keys = [...symptoms_map.keys()];

    let max_y = 10000;

    const margin = 80;
// const height = d3.select('#scene').node().clientHeight - 2 * margin;
    const height = 400 - 2 * margin;
    const width = d3.select('.symptoms_bar_chart').node().clientWidth - 2 * margin;

    d3.select("#symptoms_bar_chart").html("");
    const svg = d3.select('#symptoms_bar_chart');
    svg.attr('height', height + 2 * margin);
    svg.attr('width', width + 2 * margin);

    const chart = svg.append('g')
        .attr('transform', `translate(${margin}, ${margin})`);

    const yScale = d3.scaleLinear()
        .range([height, 0])
        .domain([0, max_y]);

    chart.append('g')
        .call(d3.axisLeft(yScale));

    const xScale = d3.scaleBand()
        .range([0, width])
        .domain(symptom_keys)
        .padding(0.2);

    chart.append('g')
        .attr('transform', `translate(0, ${height})`)
        .call(d3.axisBottom(xScale))
        .selectAll("text")
        .attr("y", 0)
        .attr("x", 9)
        .attr("dy", ".35em")
        .attr("transform", "rotate(30)")
        .style("text-anchor", "start");

    const makeYLines = () => d3.axisLeft()
        .scale(yScale);

    chart.append('g')
        .attr('class', 'grid')
        .call(makeYLines()
            .tickSize(-width, 0, 0)
            .tickFormat('')
        );

    const barGroups = chart.selectAll()
        .data(symptom_keys)
        .enter()
        .append('g');

    barGroups
        .append('rect')
        .attr('class', 'bar')
        .attr('x', (symptom) => xScale(symptom))
        .attr('y', (symptom) => yScale(symptoms_map.get(symptom)))
        .attr('height', (symptom) => height - yScale((symptoms_map.get(symptom))))
        .attr('width', xScale.bandwidth());
        // .on('mouseenter', function (actual, i) {
        //     d3.selectAll('.value')
        //         .attr('opacity', 0);
        //
        //     d3.select(this)
        //         .transition()
        //         .duration(300)
        //         .attr('opacity', 0.6)
        //         .attr('x', (a) => xScale(a) - 5)
        //         .attr('width', xScale.bandwidth() + 10);
        //
        //     const y = yScale(symptoms_map.get(actual));
        //
        //     // line = chart.append('line')
        //     //     .attr('id', 'limit')
        //     //     .attr('x1', 0)
        //     //     .attr('y1', y)
        //     //     .attr('x2', width)
        //     //     .attr('y2', y);
        //
        //     barGroups.append('text')
        //         .attr('class', 'divergence')
        //         .attr('x', (a) => xScale(a) + xScale.bandwidth() / 2)
        //         .attr('y', (a) => yScale(symptoms_map.get(a)) + 30)
        //         .attr('fill', 'white')
        //         .attr('text-anchor', 'middle')
        //         .text((a, idx) => {
        //             const divergence = (a - actual).toFixed(1);
        //
        //             let text = '';
        //             if (divergence > 0) text += '+';
        //             text += `${divergence}%`;
        //
        //             return idx !== i ? text : '';
        //         })
        //
        // })
        // .on('mouseleave', function () {
        //     d3.selectAll('.value')
        //         .attr('opacity', 1);
        //
        //     d3.select(this)
        //         .transition()
        //         .duration(300)
        //         .attr('opacity', 1)
        //         .attr('x', (a) => xScale(symptoms_map.get(a)))
        //         .attr('width', xScale.bandwidth());
        //
        //     chart.selectAll('#limit').remove();
        //     chart.selectAll('.divergence').remove()
        // });
}